%implements ftm_s32k_fault_isr "C"

%% Copyright (c) 2018 NXP.
%% All rights reserved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Function executes once per block type before code generation begins
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockTypeSetup(block, system) void
    %if FEVAL("mbd_s32k_is_codegen_compatible", CompiledModel.Name)

    %<LibAddToCommonIncludes("ftm_fault_irq.h")>
    %<LibAddToCommonIncludes("ftm_pwm_driver.h")>
    %<LibAddToCommonIncludes("ftm_common.h")>
    %<LibAddToCommonIncludes("ftm_hw_access.h")>
    %<LibAddToCommonIncludes("interrupt_manager.h")>

    %endif
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Function executes once and only once at the beginning of the simulation
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Start(block, system) Output
    %if FEVAL("mbd_s32k_is_codegen_compatible", CompiledModel.Name)
    %assign blockPath = LibGetBlockPath(block)

    %assign params = FEVAL("mbd_s32k_ftm_pwm_fault_sdk_params", blockPath)      
    %with params.user_config
    %if !EXISTS("PWM_FAULT_%<ftmModule>_INITIALIZATION")
        %assign ::PWM_FAULT_%<ftmModule>_INITIALIZATION = 1
        %<LibAddToCommonIncludes("ftm%<ftmModule>_fault_isr.h")>
        %% Interrupt handler body file
        %openfile isr_c = "ftm%<ftmModule>_fault_isr.c"
            #include "ftm%<ftmModule>_fault_isr.h"
        %closefile isr_c

        %% Interrupt handler declaration file
        %openfile isr_h = "ftm%<ftmModule>_fault_isr.h"
            #include "%<CompiledModel.Name + ".h">"
            #include "%<CompiledModel.Name + "_private.h">"
        %% Creating the file and adding the define directives
            #ifndef FTM%<ftmModule>_FAULT_ISR_H
            #define FTM%<ftmModule>_FAULT_ISR_H
        %closefile isr_h
    %endif

    %%Adding the handler function for the pin fault handler
    %openfile isr_c = "ftm%<ftmModule>_fault_isr.c","a"
        void FTM%<ftmModule>_fault_ch_%<faultChannel>_isr(void)
        {
            /* FTM%<ftmModule>: Fault channel %<faultChannel> */
            /* Attached S-Function call */
            %foreach fcnCallIdx = NumSFcnSysOutputCalls
            %% call the downstream system
            %with SFcnSystemOutputCall[fcnCallIdx]
                %% skip unconnected function call outputs
                %if ISEQUAL(BlockToCall, "unconnected")
                    continue
                %endif

                %<LibBlockExecuteFcnCall(block, fcnCallIdx)>
            %endwith
            %endforeach
        }
    %closefile isr_c

    %%  Interrupt handler declaration file
    %openfile isr_h = "ftm%<ftmModule>_fault_isr.h","a"
        void FTM%<ftmModule>_fault_ch_%<faultChannel>_isr(void);

        %%checking if pragmas needs to be closed
        %assign faultNumber = FEVAL("mbd_s32k_ftm_pwm_fault_get_blocks_number", "%<ftmModule>")
        %if !EXISTS("PWM_FAULT_%<ftmModule>_FAULT_NUMBER")
            %assign ::PWM_FAULT_%<ftmModule>_FAULT_NUMBER = 1
        %else
            %assign ::PWM_FAULT_%<ftmModule>_FAULT_NUMBER = ::PWM_FAULT_%<ftmModule>_FAULT_NUMBER + 1
        %endif
        %if ::PWM_FAULT_%<ftmModule>_FAULT_NUMBER == faultNumber
            #endif
        %endif
    %closefile isr_h

    %% Adding function to the structure
    FTM_FAULT_DRV_InstallCallback(FTM_PWM%<ftmModule>, %<faultChannel>, &FTM%<ftmModule>_fault_ch_%<faultChannel>_isr);
    %endwith

    %endif
%endfunction
